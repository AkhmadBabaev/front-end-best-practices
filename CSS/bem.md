1. #### Соглашение об именованиях:
    * Блок, элемент — всегда имя существительное (noun)
    * Модифатор — должен удовлетворять свойстам [модификатора из английского языка](https://en.wikipedia.org/wiki/Grammatical_modifier). Всегда `adjective` или `adjectival phrase`.
    * Таким образом, фразы на английском языке  `"$BLOCK_NAME [is] $MODIFIER_NAME"`, `"$ELEMENT_NAME [is] $MODIFIER_NAME"` или `"$MODIFIER_NAME $BLOCK_NAME"`, `"$MODIFIER_NAME $ELEMENT_NAME"` должны быть синтаксически корректными словосочетаниями. Примеры <i>корректных имён:</i>
      - `input_selected` — `selected input` — выделенный инпут или `input is selected` — инпут выделен;
      - `header_large` — `large header` — большой заголовок;
      - `form__save_small`, для элемента save (который, например, вешается на кнопку) — `small save` — маленький сохранить, `save small` — сохранить маленький. Правильно будет употребить noun вместо `verb`  и переименовать элемент в `save-button;` `small save-button` — маленькая кнопка сохранения
      - `input_focus` — `input focus` — инпут сфокусировать или `input is focus` — инпут это фокус. Правильно будет употребить `adjective` вместо `noun/verb` и переименовать модификатор в `focused; input_focused` — `focused input` — сфокусированный инпут.
      - `row_error` — `row error` — ошибка строки или `row is error` — строка это ошибка; Правильно будет употребить `adjectival phrase` вместо `noun `и переименовать модификатор в `with-error;` `row_with-error` — `row with  error` — строка с ошибкой.
    
2. #### Верстаем всегда по БЭМу, архитектура верстки должна быть компонентной

3. #### Каждый компонент - отдельный блок из методологии БЭМ.

4. #### Каждый компонент должен быть иметь только явные зависимости, должен быть самодостаточен
    >Все зависимости явно делать импортируя в начале компонента и вставляя в нужное место верстки
    > Самодостаточность говорит о том, что каждый компонент должен внутри себя содержать все необходимое - всю верстку, все стили и все js-скрипты

    > Ничего лишнего в компоненте быть не должно:
    > * Не должно быть определения других блоков внутри этого блока
    > * Не должно быть стилей, которые бы влияли на другие блоки любым способом 
    > * Не должно быть глобальных стилей (например, на все теги `span`)
    > * компонента не должен влиять на `DOM` другого компонента (менять верстку крайне запрещено)

5. #### Кастомизировать компоненты только через модификаторы, никаких примесей
    > Кастомизировать блоки надо почти в любом проекте. Нам дали верстку 20 страниц, из них на 15 встречается хедер, но на 10 у хедера синий фон, на 3 серый, а на двух прозрачный. Делать такого рода кастомизацию надо, не передавая туда отдельные классы, а только путем модификаторов.
    > Допустим случай, что у нас на промо странице должен быть у хедера прозрачный фон, так как там видос на фоне. И шрифт должен быть светлый, а не темный.

    > Плохо:
    > ```
    >    .promo-page
    >      +header({classname: 'promo-page__header'})
    >  ```

    > Хорошо:
    > ```
    >    promo-page
    >      +header({background: 'transparent', font: 'light'})
    >  ```
    > При втором подходе, естественно, надо будет научиться принимать эти два параметра, добавлять самому модификаторы к нужным классам и в CSS компонента прописывать правила для этих модификаторов.

    > Это правило внедрено после болезненного опыта поддержки средней сложности проекта, и вот какие шишки набиты, используя примеси:
    > * Нарушается принцип инкапсуляции - внешний мир лезет в довольно интимную область компонента и должен знать, как там устроены стили, чтобы грамотно их модернизировать и переписывать, плюс как в примере промо страница вдруг начинает содержать стили хедера, хотя она не должна вообще про хедер знать толком
    > * Если есть 20 использований компонента на 20 разных страницах, нам после изменения одного свойства в компоненте самом придется ВСЕ 20 страниц вручную тестировать, потому что неизвестно какие могут быть стили навешаны в местах использования через кастомные классы и надо самому проверить все комбинации.
    > * Примесь обычно вешается только на верхний уровень компонента, но иногда надо кастомизировать что нибудь внутреннее, тогда получается, надо уже две примеси передавать и принимать в компоненте, одна примесь для свойств всего блока, второй для какого-то элемента, а когда понадобится еще другой элемент кастомизировать, придется добавить третью примесь :)
    > * Не получится четко составить список всех возможных состояний компоненты, а при подходе с модификаторами мы явно видим все возможные параметры на входе и когда их число будет зашкаливать, можем пнуть дизайнера, что он слишком расфантазировался и пора бы к единому стайлгайду переходить.

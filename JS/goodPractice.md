1. **Знать и использовать стайлгайд от AirBnB**;
    > Сам он расположен [здесь](https://github.com/airbnb/javascript).
    > Для него есть переводы, в том числе на русском, но читать надо оригинал, так как там описаны ES6 фичи.
    > Все, что перечислено в гайде принять к исполнению, если это не перекрыто нашими правилами ниже
2. **Использовать `eslint` или аналоги**;

3. **Соглашение об именованиях:**

    1. [Переменные](./naming.md)

    2. Функции:
      * Все имена функций, за редкими исключениями (например, следование уже устоявшемуся соглашению в рамках какой-нибудь библиотеки), должны начинаться с глаголов;
      * Функции высшего порядка, возвращающие функции, следует именовать по шаблону make + .* + отглагольное существительное, где .* — опциональный, синтаксически корректный набор слов уточняющий предназначение функции. Например, `makeButtonClickHandler`.

        Обработчики событий:
        * Пропсы react-компоненты, относящиеся к обработке событий, должны именоваться по шаблону `onEventName`, где `EventName` — имя обрабатываемого события. Каждое значение такой пропсы должно именоваться по шаблону `handleComponentNameEventName`.  Пример: `<Modal onClose={this.handleModalClose} />`.
        * Обработчики событий на хост-узлах внутри компоненты (div, span и т.д.) должны именоваться по шаблону `onElementNameEventName`, где `ElementName` - имя БЭМ-элемента. Пример: `<div className="block__cancel-button" onClick={this.handleCancelButtonClick} />`.

          Обоснование: именуя колбэки по такому шаблону, мы не будем тратить время на придумывание имени и всегда можем понять предназначение колбэка лишь посмотрев на его имя. Примечание: в случаях, когда тело обработчика используется где-то ещё, то его следует выносить в отдельную функцию: например, обработчик `handleButtonClick`, выводящий список итемов, может передаваться только в пропс `onClick` БЭМ-элемента "button"; если же требуется вывести список итемов еще в каких-то других случаях, то следует сделать следующим образом:
          ```
          handleButtonClick() {
            showItems();
          }

          showItems() {
            ...
          }

4. **Методы**;

    *Именование:*
      * Имя метода должно быть `self descriptive`(описывать само себя). Из названия должно быть понятно для чего нужен метод и что он делает. Не должно быть причин задумываться о его внутренней реализации.

    *Параметры:*
      * Если в метод необходимо передать много параметров, объединяйте их в один объект. Например, у вас есть метод, который рисует прямоугольник принимая координаты точек, ширину, высоту, цвет, толщину рамок и другие параметры. В таком случае, проще будет передать один объект ‘options’. Это снимет с нас обязанность держать в голове все параметры, а также их порядок, и позволит удобно сделать многие свойства с дефолтными значениями;
      * В случае, когда параметры передаются объектом, получать их значения предпочтительнее с помощью деструктуризации;
      * Если параметр опциональный, необходимо ему задать значение по умолчанию.

    *Тело:*
      * Соблюдать принцип Single Responsibility. Метод должен выполнять только одну задачу (например, метод `createReport`, который создает отчет и отправляет его на сервер необходимо разделить на два: `createReport` и `sendReport`);
      * Метод должен быть компактным. Обычно, длина метода варьируется в пределах 10-40 строк. Это не значит что ваш метод обязательно должен должен быть в таких рамках, но если ваш метод занимает 200 строк, это повод задуматься о том, можно ли его разделить на несколько отдельных методов. Про компактность методов можно почитать у С. Макконела “Совершенный код” и Р. Мартина “Чистый код”. Так же [здесь](https://softwareengineering.stackexchange.com/questions/133404/what-is-the-ideal-length-of-a-method-for-you) Неплохое рассуждение о размерах метода.

5. **Делайте время жизни переменных как можно короче**;
    > Объявление переменной должно быть рядом с местом ее использования. Это дает более быстрое понимание того, что происходит в коде, плюс снижается вероятность неправильного использования переменной или ее перезапись.
    > Более подробнее про время жизни переменной можно прочитать у С. Макконнелла в "Совершенном коде".

6. **Все кнопки сабмита должны быть внутри `<form>` вместе со всеми соответсвующими инпутами. Обработку завершения заполнения вешать на событие `submit` формы, а не клик по кнопке**;
    > Это очень важное правило для UX, которое часто упускается новичками. Еще раз: не вешайте обработку заполнения формы на событие `click` у кнопки, а вешайте на событие `submit` у формы. Как минимум, `submit` формы может быть вызван дополнительными путями - например, нажатие на enter у любого `input`, и, совершая ошибку, вы серьезно нарушаете UX всего сайта.

7. **Все проверки содержащие более одного условия должны быть вынесены**;
    > Выносить в отдельную архитектурную единицу: переменную или функцию.
    > Плохо:
    >```javascript
    >  if ((this.allowUpdate) && ((user.isAdmin) || (user.role === item.owner)) {
    >    this.update(item.data);
    >  }
    >```
    > Хорошо:
    >```javascript
    >  function isUpdateAllowedForUser(user, item) {
    >    return (this.allowUpdate) && ((user.isAdmin) || (user.role === item.owner);
    >  }
    >  //.. в нужном месте
    >  if (this.isUpdateAllowedForUser(user, item)) {
    >    this.update(item.data);
    >  }
    >```
    > Тоже хорошо (пример ветвистого кода с кучей условий, где все именованно и раскидано, а поэтому понятно)
    >```javascript
    >  const isTodayRequested = day === 'today';
    >  const isTomorrowRequested = day === 'tomorrow';
    >  const isDepartTomorrow = departure.day() !== now.day() && unix(departure) > unix(now);
    >  const isDepartToday = departure.day() === now.day();
    >  const isRequestedDayIncorrect = (isDepartToday && !isTodayRequested) || (isDepartTomorrow && !isTomorrowRequested);
    >  const result = isRequestedDayIncorrect ? getPreviousDay(day) : day;
    >```
    > Вынос условий и их раскидывание по разным функциям/переменным позволяет каждому условию дать человеческое имя и потом ваши коллеги могут удобно читать все логические взаимосвязи не в шифре, а в удобном виде, почти как художественный текст.

8. **Всегда избегать неявного приведения типов в js**;
    > В нашем любимом языке можно складывать массивы со строками, объекты с числами и тд. Но делать этого, конечно же, не надо. Всегда явно преобразуйте переменные к одному типу при их сложении, вычитании, делении и умножении.
    > Плохо:
    >```javascript
    >  const lifes = [true, false, false, true, true];
    >  aliveTotal = 0;
    >  for (let i = 0; i < lifes.length; i++) {
    >    aliveTotal += lifes[i];  // тут мы к числу прибавляем элемент массива, который булин.
    >  }
    >```
    > Самое ужасное, что код этот будет работать, но в нем все слишком уязвимо и его чтобы поддерживать, надо постоянно в голове держать, что там булины с числами складываются.

9.  **Не изменять прототипы стандартных конструкторов (например, `String.prototype` или `Function.prototype`), до тех пор пока вопрос внимательно не изучен и этот трюк не согласован со страшим разработчиком**;

10. **Конструктор класса должен быть максимально легковесным**;
      >Например, если требуется провести поиск по DOM-дереву для задания значений полям класса, то нужно вынести этот функционал в отдельный метод. Так же в случае если нужно задать обработчики для событий - в отдельный метод.

11. **Выносить обработчики событий в отдельные функции**;
    > Не стоит создавать анонимные функции прямо в том же месте, где идет привязка к событию.
    > Плохо:
    >```javascript
    >  elem.addEventListener( "click" , function() {alert('Спасибо!')});
    >```
    > Хорошо:
    >```javascript
    >  class Component {
    >
    >    bindEventListeners() {
    >      stopButton.addEventListener('click', this.handleStopButtonClick);
    >    }
    >
    >    handleStopButtonClick() {
    >      ...
    >    }
    >  }
    >```

12. **В обработчиках работать не с контекстом (this), а с аргументом объекта ивента, который был передан свыше**;
    > Не полагаться на this при работе с объектами событий, а использовать первый параметр коллбека event.
    > Работать только с тем, что приходит из события. JS позволяет вносить дополнительные данные в event.
    > То есть не использовать "this.value". Вместо этого получать данные через объект события  "e.currentTarget.value".
    > Плохо:
    >```javascript
    >handleButtonClick() {
    >  const buttonWidth = $(this).width();
    >  ...
    >}
    >```
    >
    >Хорошо:
    >```javascript
    >handleButtonClick(event) {
    >  const buttonWidth = $(event.currentTarget).width();
    >  ...
    >}

13. **Стараться по максимуму избегать циклов и использовать встроенные методы массивов**;
    > `.map`, `.filter` и тд обычно гораздо проще читаются, плюс функцию обработки одного элемента можно вынести и многократно использовать в разных местах.

14. **Не использовать литералы из бизнес-логики напрямую - надо создавать объект с константами**;
    > Если в бизнес-логике есть какой-то параметр, то надо создать где-то переменную, желательно в специальном месте для конфига, туда выносить все фиксированные значения, а в коде использовать их только по именам.
    > Можно:
    >```javascript
    >  if (status === ordersModule.ACTIVE_STATUS) {...}
    >```
    > Нельзя:
    >```javascript
    >  if (status === 'active') {...}
    >```

15. **Форматирование размещения импортов:**
    > Импорты объединяются в секции, секции разделяются переносом строки.
    > Для фронта выделяются три секции (в таком порядке размещения):
    > * Абсолютные импорты из node_modules;
    > * Абсолютные импорты из src;
    > * Относительные импорты, отсортированные в порядке убывания переходов на более верхний уровень в дереве пути (через ../).
    > Например:
    >```javascript
    >  import * as React from 'react';
    >  import block from 'bem-cn';
    >  import { connect, Dispatch } from 'react-redux';
    >  import { bindActionCreators } from 'redux';
    >  import { arrayPush } from 'redux-form';
    >
    >  import { Modal } from 'shared/view/elements';
    >  import { IPreset } from 'shared/types/models';
    >  import { IAppReduxState } from 'shared/types/app';
    >  import { actions as notificationActions } from 'services/notification';
    >  import { selectors as configSelectors } from 'services/config';
    >
    >  import { actions, selectors } from '../../../redux';
    >  import { managePresetsFormEntry } from '../../../redux/reduxFormEntries';
    >  import { Presets } from '../../components/ManagePresets';
    >  import './ManagePresets.scss';
    >```
    > Также, для любого поддерева элемента пути не должно быть такого поддерева, импорты которого разделяются другим поддеревом такой же глубины.
    > Например:
    > Импорты поддерева `shared` (глубина 1) разделяются импортом поддерева services.
    >```javascript
    >  import { IModel } from 'shared/types/models';
    >  import { i18nConnect } from 'services/i18n';
    >  import { Component } from 'shared/view/components';
    >```
    >***Правильно будет так:***
    >```javascript
    >  import { IModel } from 'shared/types/models';
    >  import { Component } from 'shared/view/components';
    >  import { i18nConnect } from 'services/i18n';
    >```
    >*Или в:*
    >```javascript
    >  import { IAppReduxState } from 'shared/types/app';
    >  import { Component } from 'shared/view/components';
    >  import { IModel } from 'shared/types/models';
    >  import { i18nConnect } from 'services/i18n';
    >```
    >***импорты поддерева `shared/types` (глубина 2) разделяются импортом поддерева `shared/view`. Правильно будет так:***
    >```javascript
    >  import { IAppReduxState } from 'shared/types/app';
    >  import { IModel } from 'shared/types/models';
    >  import { Component } from 'shared/view/components';
    >  import { i18nConnect } from 'services/i18n';
    >```

16. **Экспорты держать в конце файла**;
    > Плохо:
    >```javascript
    >  export class Foo {
    >    // ...
    >  }
    >  export class Bar {
    >  // ...
    >  }
    >  // finita la comedia
    >```
    > Хорошо:
    >```javascript
    >  class Foo {
    >  // ...
    >  }
    >  class Bar {
    >  // ...
    >  }
    >  export {
    >    Foo,
    >    Bar,
    >  };
    >```

17. **Если есть сомнения, поддерживает ли браузер какую-либо фичу - проверять непосредственно определена ли эта функция, а не сравнивать `user-agent` с названиями и версиями браузеров, которые по документации это поддерживают. А по хорошему вообще использовать [Modernizr](https://modernizr.com/)**;

18. **Избегать глобальных переменных**;
    > Почти в любом языке глобальные переменные - источник зла. В JavaScript это правило не исключение.
    > Глобальные переменные делают работу программы непредсказуемой и усложняют изучение логики работы кода, плюс вызывает головокружение и гневные крики у опытных разработчиков при своем появлении.
    > Чаще всего пользоваться глобальными переменными можно только потому что, так требуют олдскульные библиотеки, например Google Maps, которая создает глобальный объект google и карты можно кастомизировать только через него, и которая для колбека при своей инициации просит создать глобальную функцию, которую Google Maps потом сама вызовет.
    > Можно на первых стадиях совсем простых проектов, где чуть-чуть анимаций на jquery использовать одну (и только одну) глобальную переменную, чтобы сохранять в нее модули и иметь возможность доступа к функциям из других js-файлов (по умолчанию сам js этого не поддерживает).

19. **К глобальным переменным обращаться только как к свойствам window**;
    >И создавать объекты только как свойства window, потому что объявление без var неочевидно - так же происходят переопределения переменных из замыкания и сложно отличить эти моменты.
    >```javascript
    >  // тут правило нарушено, создается глобальная переменная без window, и обращение к ней тоже без window:
    >  function test () {
    >    foo = 'hello world';  // обратить внимание, что переменная создана без var, значит она глобальная
    >  }
    >  test();
    >  console.log(foo) // вывод 'hello world', обращение тоже без window
    >```
    >
    >```javascript
    >  // тут следуют описанная глобальная переменная, как надо:
    >  function test () {
    >    window.foo = 'hello world';
    >  }
    >  test();
    >  console.log(window.foo) // вывод 'hello world', обращение как к >свойству объекта window
    >```

20. **Используйте специальные обертки для логирования, а не сырой `console.log`**;
    > Вообще, логирование - это отдельное искусство, хорошие правила были описаны в [этой презентации](https://www.slideshare.net/nzakas/enterprise-javascript-error-handling-presentation/2-Whos_this_g_uy_P).
    > * У каждого лога должен быть префикс, который говорит из какого модуля вызван лог и в какое время он был вызван (таймстеймп);
    > * Разделять логирование как минимум на два уровня - `debug` и `production`, чтобы в production сборке не выводились логи для разработчиков;
    > * Все логи, которые ваша система производит, должны сохраняться в какую-либо единую переменную, чтобы в случае ошибок можно было сразу все отправить на сервер.

21. **Старый код надо удалять, а не комментировать. Если он понадобится в дальнейшем, всегда можно будет посмотреть в истории коммитов**;
    > Это в первую очередь предназначено для ваших коллег - большие куски лишнего кода сбивают с толку, мешают поиску через `ctrl+F`, заставляют иногда отвлекаться на изучение кода. Так что лучше его скрыть в истории изменений.

22. **Все изменения в стилях, которые можно сделать через переключение классов у элемента, надо делать через добавление/удаление классов, а не простановку стилей у DOM-элементов. Так, например, можно переключать видимость элемента. Однако для непрерывно изменяющихся численных значений так сделать уже не получится, как например при изменении свойства `top` при скролле страницы, поэтому тут придётся все-таки проставлять напрямую у элемента значение в css-свойстве.**;
    > Это не только увеличит производительность (потому что за раз вы примените сразу все стили от нового класса), но и поможет потом переписать стили из css нормальным способом, потому что иначе стили будут инлайновые и из css их нельзя будет переопределить, кроме как через `!important`.

23. **Очень полезно понимать, как работают циклы перерисовки браузера и как можно проверить и увеличить производительность работы с DOM - здесь в статье перечислены [полезные источники](https://isobar-us.github.io/code-standards/#javascript_javascript_performance)**;

24. **Код должен быть без орфографических ошибок. Имена переменных, функций, комментарии должны быть написаны правильно**;
    > Обычно, чтобы избежать большинства ошибок, используют расширения для `IDE`, для `vscode` например есть хорошее расширение [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker).

25. **Вся работа со службами браузера (`navigator services`, `cookie`, `localStorage`) должна быть обернута в try/catch, т.к. это внешние по отношению к нашему коду службы, от которых не ясно, чего ждать. На спеки тут полагаться не стоит, т.к. есть и новые движки, которые имеют в том числе баги в своих сорцах**;
    > В сафари если включен режим инкогнито или если в браузере стоит блокировка `cookie`, то браузер будет райзить ошибку. Поэтому если ее не отловить, приложение посыпется :)
